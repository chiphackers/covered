<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Covered Report Viewer User Manual - Combinational Logic Window</title>
</head>
<body bgcolor="#ffffff">
<div align="center"><img src="images/banner.gif" width="258" height="105" alt="Covered - The Verilog Code Coverage Analyzer"></div>
<br>
<div align="center">
  <a href="toggle.html">&lt; Prev</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <a href="welcome.html">Table of Contents</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <a href="summary.html">Next &gt;</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div>
<hr>
<h1>Navigating the Combinational Logic Window</h1>
<hr>

<p>
The Verbose Combinational Logic viewer allows the user to look at the subexpressions of
a selected statement to determine exactly why a statement did not achieve 100% coverage.
The window is split up into two text frames.  The top frame displays the selected
statement, underlining and numbering subexpressions that were found to not achieve full
coverage.  The bottom frame displays which combinations of a selected subexpression
were hit/missed, allowing the user to discern which combinations of logic are still in
need of verification.  Figure 1 shows a snapshot of the Verbose Combinational Logic
viewer window.
</p>

<h2>Navigating a Statement</h2>

<p>
To understand what subexpressions of a statement caused it to not achieve 100% coverage,
the viewer window allows the user to traverse uncovered subexpressions, displaying the
coverage information for each subexpression in the lower frame.  To see an uncovered
subexpression in the lower frame, simply left click on the underlined subexpression.  If
the subexpression has one or more children subexpressions, these will be individually
underlined and numbered.  If the subexpression is a leaf subexpression of the statement,
only its coverage information will be displayed in the lower pane.  To traverse upward
in a subexpression, simply click on the right button.  This will cause the parent
subexpression to be underlined and its parent (if one exists) will have its coverage
information displayed in the lower frame.
</p>

<h2>Understanding the Coverage Information</h2>

<p>
The coverage information for a selected subexpression can be one of four different
types:</p>

<p>
<ol>
  <li><b>Event Subexpression</b>
    <p>These subexpressions do not have any children expressions.  Their coverage is
    in terms of:</p>
    <p><ul>
      <li>Did this event occur?</li>
    </ul></p>
    <p>The following operators are considered events:</p>
    <p><ul>
      <li><b>At-event operators</b>:<br>
          &nbsp;&nbsp;<b>@(posedge</b> <i>expression</i> <b>)</b><br>
          &nbsp;&nbsp;<b>@(negedge</b> <i>expression</i> <b>)</b><br>
          &nbsp;&nbsp;<b>@(</b> <i>expression</i> <b>)</b><br>
          &nbsp;&nbsp;<b>@*</b></li>
      <li><b>Event trigger operator</b>:<br>
          &nbsp;&nbsp;<b>-></b> <i>event_variable</i></li>
    </ul></p>
    <div align="center">
      <p><b>Figure 3.  Example Coverage Output for an Uncovered Event Subexpression</b></p>
      <img src="images/comb_event.png" alt="Uncovered Event Subexpression Output">
    </div>
    <p>In this diagram, we see that a certain @(posedge clock) expression never 
    occured.</p>
  </li>
  
  <li><b>Unary Subexpression</b>
    <p>These subexpressions do not have any children expressions.  Their coverage is
    in terms of:</p>
    <p><ul>
      <li>Did this expression evaluate to a value of 0?</li>
      <li>Did this expression evaluate to a non-zero value?</li>
    </ul></p>
    <p>The following operators are considered unary subexpressions:</p>
    <p><ul>
      <li><b>Signal/Bit Selectors</b>:<br>
          &nbsp;&nbsp;<i>signal_value</i><br>
          &nbsp;&nbsp;<i>signal_value</i> <b>[</b> <i>expression</i> <b>]</b><br>
          &nbsp;&nbsp;<i>signal_value</i> <b>[</b> <i>value</i> <b>:</b> <i>value</i> <b>]</b><br>
          &nbsp;&nbsp;<i>signal_value</i> <b>[</b> <i>expression</i> <b>+:</b> <i>value</i> <b>]</b><br>
          &nbsp;&nbsp;<i>signal_value</i> <b>[</b> <i>expression</i> <b>-:</b> <i>value</i> <b>]</b></li>
      <li><b>Function call</b>:<br>
          &nbsp;&nbsp;<i>function_name</i> <b>( ... )</b></li>
      <li><b>Mathematical operators</b>:<br>
          &nbsp;&nbsp;<i>expression</i> <b>*</b> <i>expression</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>/</b> <i>expression</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>%</b> <i>expression</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>**</b> <i>expression</i><br>
          &nbsp;&nbsp;<b>-</b> <i>expression</i></li>
      <li><b>Relational operators</b>:<br>
          &nbsp;&nbsp;<b>!</b> <i>expression</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>&lt;</b> <i>expression</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>&gt;</b> <i>expression</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>&lt;=</b> <i>expression</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>&gt;=</b> <i>expression</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>==</b> <i>expression</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>!=</b> <i>expression</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>===</b> <i>expression</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>!==</b> <i>expression</i></li>
      <li><b>Shift operators</b>:<br>
          &nbsp;&nbsp;<i>expression</i> <b>&lt;&lt;</b> <i>value</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>&gt;&gt;</b> <i>value</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>&lt;&lt;&lt;</b> <i>value</i><br>
          &nbsp;&nbsp;<i>expression</i> <b>&gt;&gt;&gt;</b> <i>value</i></li>
      <li><b>Conditional operator</b>:<br>
          &nbsp;&nbsp;<i>expression</i> <b>?</b> <i>expression</i> <b>:</b> <i>expression</i></li>
      <li><b>Unary operators</b>:<br>
          &nbsp;&nbsp;<b>~</b> <i>expression</i><br>
          &nbsp;&nbsp;<b>&</b> <i>expression</i><br>
          &nbsp;&nbsp;<b>|</b> <i>expression</i><br>
          &nbsp;&nbsp;<b>^</b> <i>expression</i><br>
          &nbsp;&nbsp;<b>~&</b> <i>expression</i><br>
          &nbsp;&nbsp;<b>~|</b> <i>expression</i><br>
          &nbsp;&nbsp;<b>~^</b> <i>expression</i></li>
      <li><b>Concatenation operators</b>:<br>
          &nbsp;&nbsp;<b>{</b> <i>value</i> <b>{</b> <i>expression</i> <b>} }</b><br>
          &nbsp;&nbsp;<b>{</b> <i>expression</i> <b>,</b> <i>expression</i> <b>, ... }</b></li>
      <li><b>Case equality</b></li>
    </ul></p>
    <div align="center">
      <p><b>Figure 4.  Example Coverage Output for an Uncovered Unary Subexpression</b></p>
      <img src="images/comb_unary.png" alt="Uncovered Unary Subexpression Output">
    </div>
  </li>
  
  <li><b>Simple Combinational Subexpression</b>
    <p>These subexpressions have two child expressions (L=left and R=right).  There are three
    flavors of simple combinational subexpressions:  AND-type, OR-type and other.  The differences
    are explained below.
    <p><ul>
      <li><b>Simple AND-type Combinational Subexpressions</b>
          <p>These subexpressions have three possible combinational outcomes:
          <p><ul>
            <li>Did the left expression evaluate to 0?</li>
            <li>Did the right expression evaluate to 0?</li>
            <li>Did the left expression evaluate to 1 when the right expression evaluated to 1?</li>
          </ul></p>
          <p>The following operators are considered simple AND-like combinational subexpressions:</p>
          <p><ul>
            <li><b>Logical operators</b>:<br>
                &nbsp;&nbsp;<i>expression</i> <b>&</b> <i>expression</i><br>
                &nbsp;&nbsp;<i>expression</i> <b>~&</b> <i>expression</i><br>
                &nbsp;&nbsp;<i>expression</i> <b>&&</b> <i>expression</i></li>
          </ul></p>
          <div align="center">
            <p><b>Figure 5.  Example Coverage Output for an Uncovered Simple AND-type Combinational Subexpression</b></p>
            <img src="images/comb_simple_and.png" alt="Uncovered Simple AND-type Combinational Subexpression Output">
          </div></li>
          <p></p>
       <li><b>Simple OR-type Combinational Subexpressions</b>
          <p>These subexpressions have three possible combinational outcomes:
          <p><ul>
            <li>Did the left expression evaluate to 1?</li>
            <li>Did the right expression evaluate to 1?</li>
            <li>Did the left expression evaluate to 0 when the right expression evaluated to 0?</li>
          </ul></p>
          <p>The following operators are considered simple OR-like combinational subexpressions:</p>
          <p><ul>
            <li><b>Logical operators</b>:<br>
                &nbsp;&nbsp;<i>expression</i> <b>|</b> <i>expression</i><br>
                &nbsp;&nbsp;<i>expression</i> <b>~|</b> <i>expression</i><br>
                &nbsp;&nbsp;<i>expression</i> <b>||</b> <i>expression</i></li>
          </ul></p>
          <div align="center">
            <p><b>Figure 6.  Example Coverage Output for an Uncovered Simple OR-type Combinational Subexpression</b></p>
            <img src="images/comb_simple_or.png" alt="Uncovered Simple OR-type Combinational Subexpression Output">
          </div></li>
          <p></p>
       <li><b>Simple Other-type Combinational Subexpressions</b>
          <p>These subexpressions have three possible combinational outcomes:
          <p><ul>
            <li>Did the left expression evaluate to 0 when the right expression evaluated to 0?</li>
            <li>Did the left expression evaluate to 0 when the right expression evaluated to 1?</li>
            <li>Did the left expression evaluate to 1 when the right expression evaluated to 0?</li>
            <li>Did the left expression evaluate to 1 when the right expression evaluated to 1?</li>
          </ul></p>
          <p>The following operators are considered simple combinational subexpressions:</p>
          <p><ul>
            <li><b>Mathematical operators</b>:<br>
                &nbsp;&nbsp;<i>expression</i> <b>+</b> <i>expression</i><br>
                &nbsp;&nbsp;<i>expression</i> <b>-</b> <i>expression</i></li>
            <li><b>Logical operators</b>:<br>
                &nbsp;&nbsp;<i>expression</i> <b>^</b> <i>expression</i><br>
                &nbsp;&nbsp;<i>expression</i> <b>~^</b> <i>expression</i></li>
          </ul></p>
          <div align="center">
            <p><b>Figure 5.  Example Coverage Output for an Uncovered Simple Combinational Subexpression</b></p>
            <img src="images/comb_simple.png" alt="Uncovered Simple Combinational Subexpression Output">
          </div></li>
    </ul></p>
  
  <li><b>Complex Combinational Subexpression</b>
    <p>These subexpression have three or more child expressions that all are connected
    by the same operator.  For example, the statement a = (b & c & d) would contain the
    complex combinational subexpression of (b & c & d) where b, c and d are the three
    child expressions all combined using the bitwise AND operator.</p>
    <p>The effect of each subexpression on the value of the entire subexpression as well 
    as the combination of each child toward the parent is displayed.  For example, if the
    combinational operator is a bitwise OR, each child is checked to see if it evaluated 
    to TRUE (in an OR operation, only one subexpression needs to evaluate to TRUE for 
    the entire subexpression to be TRUE).  Additionally, all child subexpressions are 
    checked to see if all evaluated to 0 simultaneously (this is the only way to get the 
    whole subexpression to evaluate to 0).</p>
    <p>The unique identifier below each subexpression is used in the displayed coverage
    information for these types of subexpressions for identifying which subexpression
    did not behave correctly.</p>
    <p>All simple combinational subexpressions can be output as complex combinational
    subexpressions if there are three or more child subexpressions to the operation.</p>
    <div align="center">
      <p><b>Figure 6.  Example Coverage Output for an Uncovered Complex Combinational Subexpression</b></p>
      <img src="images/comb_complex.png" alt="Uncovered Complex Combinational Subexpression Output">
    </div>
    <p>In this example, subexpression 1 never evaluated to a value of TRUE (which would
    have made the entire expression TRUE) and all three subexpressions 1, 2, and 3
    were never a value of 0 simultaneously (which would have made the entire expression
    FALSE).  However, subexpressions 2 and 3 both evaluated to TRUE at some point.</p>
  </li>
</ol>
</p>

<h2>Displaying a New Statement</h2>

<p>
If the Verbose Combinational Logic Coverage window is currently displayed with a 
statement, the user may select a new statement in the 
<a href="cov_view.html">Coverage File Viewer</a> of the Main
window.  When a new statement is selected, its value immediately replaces the currently
selected statement.  This feature allows many different statements to be viewed one
after the other without having to create/destroy a new window for each.
</p>

<p>
The user may also see the previous or next uncovered statement in the main viewer by 
clicking either the "<--" button (for previous signal viewing) or the "-->" button 
(for next signal viewing).  Note that the "<--" button will be disabled if there is 
not a signal previous to the current signal in the given module and the "--> button 
will be disabled if there is not a signal after the current signal in the given module.
</p>

<h2>Close Button</h2>

<p>
Clicking the <b>Close</b> button will cause the Combinational Logic Viewer window to
close and the current selection identifier to be removed from the Coverage Viewer
in the main window.
</p>

<h2>Help Button</h2>

<p>
Clicking the <b>Help</b> button will cause this help page to be displayed in a web
brower.
</p>

</body>
</html>
