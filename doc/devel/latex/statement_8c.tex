\section{statement.c File Reference}
\label{statement_8c}\index{statement.c@{statement.c}}
{\tt \#include $<$stdio.h$>$}\par
{\tt \#include $<$assert.h$>$}\par
{\tt \#include \char`\"{}defines.h\char`\"{}}\par
{\tt \#include \char`\"{}statement.h\char`\"{}}\par
{\tt \#include \char`\"{}expr.h\char`\"{}}\par
{\tt \#include \char`\"{}util.h\char`\"{}}\par
{\tt \#include \char`\"{}link.h\char`\"{}}\par
{\tt \#include \char`\"{}sim.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
{\bf statement} $\ast$ {\bf statement\_\-create} ({\bf expression} $\ast$exp)
\begin{CompactList}\small\item\em Creates new statement structure. \item\end{CompactList}\item 
void {\bf statement\_\-stack\_\-push} ({\bf statement} $\ast$stmt, int id)
\item 
void {\bf statement\_\-stack\_\-compare} ({\bf statement} $\ast$stmt)
\item 
void {\bf statement\_\-db\_\-write} ({\bf statement} $\ast$stmt, FILE $\ast$ofile, char $\ast$scope)
\begin{CompactList}\small\item\em Writes specified statement to the specified output file. \item\end{CompactList}\item 
{\bf bool} {\bf statement\_\-db\_\-read} (char $\ast$$\ast$line, {\bf module} $\ast$curr\_\-mod, int read\_\-mode)
\begin{CompactList}\small\item\em Reads in statement line from specified string and stores statement in specified module. \item\end{CompactList}\item 
void {\bf statement\_\-connect} ({\bf statement} $\ast$curr\_\-stmt, {\bf statement} $\ast$next\_\-stmt)
\begin{CompactList}\small\item\em Connects statement sequence to next statement. \item\end{CompactList}\item 
void {\bf statement\_\-set\_\-stop} ({\bf statement} $\ast$stmt, {\bf statement} $\ast$post, {\bf bool} true\_\-path, {\bf bool} both)
\begin{CompactList}\small\item\em Sets stop bits in specified statement tree. \item\end{CompactList}\item 
void {\bf statement\_\-dealloc\_\-recursive\_\-helper} ({\bf statement} $\ast$curr, {\bf statement} $\ast$start)
\item 
void {\bf statement\_\-dealloc\_\-recursive} ({\bf statement} $\ast$stmt)
\begin{CompactList}\small\item\em Recursively deallocates specified statement tree. \item\end{CompactList}\item 
void {\bf statement\_\-dealloc} ({\bf statement} $\ast$stmt)
\begin{CompactList}\small\item\em Deallocates statement memory and associated expression tree from the heap. \item\end{CompactList}\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
char {\bf user\_\-msg} [USER\_\-MSG\_\-LENGTH]
\item 
{\bf stmt\_\-loop\_\-link} $\ast$ {\bf stmt\_\-loop\_\-stack} = NULL
\end{CompactItemize}


\subsection{Detailed Description}
\begin{Desc}
\item[Author:]Trevor Williams ({\tt trevorw@charter.net}) \end{Desc}
\begin{Desc}
\item[Date:]5/1/2002\end{Desc}
\begin{Desc}
\item[]Statements are used to indicate flow of execution for a given always or initial block. Each statement is assigned to exactly one expression tree and it contains a pointer to the next statement if its expression tree evaluates to TRUE (non-zero value) or FALSE (zero value). To minimize memory use, a statement uses some of the unused bits in its root expression supplemental field instead of having its own supplemental field. There are two bits in the expression supplemental value that are only used by expressions: {\bf SUPPL\_\-LSB\_\-STMT\_\-HEAD}{\rm (p.\,\pageref{group__expr__suppl_a4})} and {\bf SUPPL\_\-LSB\_\-STMT\_\-STOP}{\rm (p.\,\pageref{group__expr__suppl_a5})}.\end{Desc}
\begin{Desc}
\item[]The STMT\_\-HEAD bit indicates that this statement should be loaded into the pre-simulation statement queue if any of its expressions change value in the current timestep. To begin with, the first statement in the always/initial block has this bit set, all other statements have this bit cleared.\end{Desc}
\begin{Desc}
\item[]The STMT\_\-STOP bit is used for CDD output. If a statement has this bit set, it will not traverse its next\_\-true or next\_\-false paths when outputting. This is necessary when statement paths merge back to the same path. If this bit was not used, the statements output after the merge would be output twice. Consider the following Verilog code snippet:\end{Desc}


\footnotesize\begin{verbatim} intial begin
        a = 0;
        if( a )
          b = 1;
        else
          b = 0;
        c = a | b;
 end
\end{verbatim}\normalsize


\begin{Desc}
\item[]In this example there are five statements. They are the following:\end{Desc}
\begin{Desc}
\item[]\begin{enumerate}
\item 

\footnotesize\begin{verbatim} a = 0; 
\end{verbatim}\normalsize
\item 

\footnotesize\begin{verbatim} if( a ) 
\end{verbatim}\normalsize
\item 

\footnotesize\begin{verbatim} b = 1; 
\end{verbatim}\normalsize
\item 

\footnotesize\begin{verbatim} b = 0; 
\end{verbatim}\normalsize
\item 

\footnotesize\begin{verbatim} c = a | b; 
\end{verbatim}\normalsize
\end{enumerate}
\end{Desc}
\begin{Desc}
\item[]Notice that the if statement has two paths. If a is TRUE, statement 3 is executed; otherwise, statement 4 is executed. Both statements 3 and 4 then merge to execute statement 5. If the entire statement tree were printed without a STOP bit, you can see that statement 5 would be output twice; once for the TRUE branch and once for the FALSE branch.\end{Desc}
\begin{Desc}
\item[]To eliminate this redundancy, the STMT\_\-STOP bit is set on statement 4. The last statement of a TRUE path before merging always gets its STMT\_\-STOP bit set. The FALSE path should never get the STMT\_\-STOP bit set. Additionally, once a statement gets its STMT\_\-STOP bit set by the parser, this value must be maintained (never cleared).\end{Desc}
\begin{Desc}
\item[Cyclic Statement Trees]Many times a statement tree will \char`\"{}loopback\char`\"{} on itself. These statement trees are considered to be cyclic in nature and, as such, must have leaf statements of the statement tree tied to the first statement of the tree. The following Verilog constructs have cyclic behavior: {\tt always}, {\tt forever}, {\tt for}, {\tt repeat}, and {\tt while}.\end{Desc}
\begin{Desc}
\item[Traversing Statement Tree]Starting at the head statement, the value of the head statement is determined to be TRUE or FALSE. If the value is TRUE (non-zero), the next\_\-true path is taken. If the value is FALSE (zero), the next\_\-false path is taken. For statements that express an assignment (or other statements that do not branch), both the next\_\-true and next\_\-false paths point to the same statement. For statements that express a wait-for-event (ex. {\tt wait}, {\tt @}, etc.), the next\_\-true pointer will point to the next statement in the tree; however, the next\_\-false pointer will point to NULL. This NULL assignment indicates to the statement simulation engine that this statement will receive the STMT\_\-HEAD bit and the current statement tree is finished for this timestep.\end{Desc}
\begin{Desc}
\item[Other Notes]A statement must always be connected to an expression tree (this is were it gets its unique identifier and some control bits from in the first place). When a statement is deallocated, the pointer to its expression is set to a value of NULL to indicate to all other functions that this statement no longer exists. This is necessary for deallocating statement trees because a statement cannot tell other statements pointing to it that it no longer exists. When the statements connected to it are deallocated they will look at the next\_\-true and next\_\-false pointers, check to see if the expressions are NULL and do the appropriate action. This algorithm will only work as long as there are no malloc calls during the statement deallocation process.\end{Desc}


\subsection{Function Documentation}
\index{statement.c@{statement.c}!statement_connect@{statement\_\-connect}}
\index{statement_connect@{statement\_\-connect}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-connect ({\bf statement} $\ast$ {\em curr\_\-stmt}, {\bf statement} $\ast$ {\em next\_\-stmt})}\label{statement_8c_a7}


Connects statement sequence to next statement. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em curr\_\-stmt}]Pointer to statement sequence to traverse. \item[{\em next\_\-stmt}]Pointer to statement to connect ends to.\end{description}
\end{Desc}
Recursively traverses the specified stmt sequence. When it reaches a statement that has either next\_\-true or next\_\-false set to NULL, sets next\_\-true and/or next\_\-false of that statement to point to the next\_\-stmt statement. \index{statement.c@{statement.c}!statement_create@{statement\_\-create}}
\index{statement_create@{statement\_\-create}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf statement}$\ast$ statement\_\-create ({\bf expression} $\ast$ {\em exp})}\label{statement_8c_a2}


Creates new statement structure. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em exp}]Pointer to root expression of expression tree for this statement.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Returns pointer to the newly created statement.\end{Desc}
Creates a new statement structure from heap memory and initializes it with the specified parameter information. \index{statement.c@{statement.c}!statement_db_read@{statement\_\-db\_\-read}}
\index{statement_db_read@{statement\_\-db\_\-read}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} statement\_\-db\_\-read (char $\ast$$\ast$ {\em line}, {\bf module} $\ast$ {\em curr\_\-mod}, int {\em read\_\-mode})}\label{statement_8c_a6}


Reads in statement line from specified string and stores statement in specified module. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em line}]Pointer to current line of file being read. \item[{\em curr\_\-mod}]Pointer to current module. \item[{\em read\_\-mode}]If set to REPORT, adds statement to head of list; otherwise, adds statement to tail.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Returns TRUE if the line is read without error; otherwise, returns FALSE.\end{Desc}
Reads in the contents of the statement from the specified line, creates a statement structure to hold the contents. \index{statement.c@{statement.c}!statement_db_write@{statement\_\-db\_\-write}}
\index{statement_db_write@{statement\_\-db\_\-write}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-db\_\-write ({\bf statement} $\ast$ {\em stmt}, FILE $\ast$ {\em ofile}, char $\ast$ {\em scope})}\label{statement_8c_a5}


Writes specified statement to the specified output file. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em stmt}]Pointer to statement to write out value. \item[{\em ofile}]Pointer to output file to write statement line to. \item[{\em scope}]Scope of parent module which contains the specified statement.\end{description}
\end{Desc}
Recursively writes the contents of the specified statement tree (and its associated expression trees to the specified output stream. \index{statement.c@{statement.c}!statement_dealloc@{statement\_\-dealloc}}
\index{statement_dealloc@{statement\_\-dealloc}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-dealloc ({\bf statement} $\ast$ {\em stmt})}\label{statement_8c_a11}


Deallocates statement memory and associated expression tree from the heap. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em stmt}]Pointer to statement to deallocate.\end{description}
\end{Desc}
Deallocates specified statement from heap memory. Does not remove attached expression (this is assumed to be cleaned up by the expression list removal function). \index{statement.c@{statement.c}!statement_dealloc_recursive@{statement\_\-dealloc\_\-recursive}}
\index{statement_dealloc_recursive@{statement\_\-dealloc\_\-recursive}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-dealloc\_\-recursive ({\bf statement} $\ast$ {\em stmt})}\label{statement_8c_a10}


Recursively deallocates specified statement tree. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em stmt}]Pointer to head of statement tree to deallocate.\end{description}
\end{Desc}
Recursively deallocates specified statement tree. \index{statement.c@{statement.c}!statement_dealloc_recursive_helper@{statement\_\-dealloc\_\-recursive\_\-helper}}
\index{statement_dealloc_recursive_helper@{statement\_\-dealloc\_\-recursive\_\-helper}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-dealloc\_\-recursive\_\-helper ({\bf statement} $\ast$ {\em curr}, {\bf statement} $\ast$ {\em start})}\label{statement_8c_a9}


\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em curr}]Pointer to current statement to deallocate. \item[{\em start}]Pointer to statement of root of statement tree to deallocate.\end{description}
\end{Desc}
Recursively deallocates statements listed by the current statement tree. This function is called by the parser to remove statement trees that were created but found to have unsupported code in them. This function takes care to not remove the same statement twice and to not infinitely loop. \index{statement.c@{statement.c}!statement_set_stop@{statement\_\-set\_\-stop}}
\index{statement_set_stop@{statement\_\-set\_\-stop}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-set\_\-stop ({\bf statement} $\ast$ {\em stmt}, {\bf statement} $\ast$ {\em post}, {\bf bool} {\em true\_\-path}, {\bf bool} {\em both})}\label{statement_8c_a8}


Sets stop bits in specified statement tree. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em stmt}]Pointer to top of statement tree to set stop bits for. \item[{\em post}]Pointer to statement that comes just after the stopped statement. \item[{\em true\_\-path}]Set to TRUE if the current statement exists on the right of its parent. \item[{\em both}]If TRUE, causes both false and true paths to set stop bits when next statement is the post statement.\end{description}
\end{Desc}
Recursively traverses specified statement tree, setting the statement's stop bits that have either their next\_\-true or next\_\-false pointers pointing to the statement called post. \index{statement.c@{statement.c}!statement_stack_compare@{statement\_\-stack\_\-compare}}
\index{statement_stack_compare@{statement\_\-stack\_\-compare}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-stack\_\-compare ({\bf statement} $\ast$ {\em stmt})}\label{statement_8c_a4}


\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em stmt}]Pointer to statement being read out of the CDD.\end{description}
\end{Desc}
Compares the specified statement against the top of the statement loop stack. If the ID at the top of the stack matches this statement's ID, the top of the stack is popped and the next\_\-true and next\_\-false pointers of the stored statement are pointed to the specified statement. The next head is also compared against this statement and the process is repeated until a match is not found. Once an ID at the top of the stack does not match, no further action is taken. \index{statement.c@{statement.c}!statement_stack_push@{statement\_\-stack\_\-push}}
\index{statement_stack_push@{statement\_\-stack\_\-push}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-stack\_\-push ({\bf statement} $\ast$ {\em stmt}, int {\em id})}\label{statement_8c_a3}


\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em stmt}]Pointer of statement waiting to be linked. \item[{\em id}]ID of statement to be read out later.\end{description}
\end{Desc}
Creates a new statement loop link for the specified parameters and adds this element to the top of the statement loop stack. 

\subsection{Variable Documentation}
\index{statement.c@{statement.c}!stmt_loop_stack@{stmt\_\-loop\_\-stack}}
\index{stmt_loop_stack@{stmt\_\-loop\_\-stack}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf stmt\_\-loop\_\-link}$\ast$ {\bf stmt\_\-loop\_\-stack} = NULL}\label{statement_8c_a1}


Pointer to statement loop stack structure. See description of {\bf stmt\_\-loop\_\-link}{\rm (p.\,\pageref{defines_8h_a166})} for more information on this stack structure usage. \index{statement.c@{statement.c}!user_msg@{user\_\-msg}}
\index{user_msg@{user\_\-msg}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}char {\bf user\_\-msg}[USER\_\-MSG\_\-LENGTH] ()}\label{statement_8c_a0}


Holds some output that will be displayed via the print\_\-output command. This is created globally so that memory does not need to be reallocated for each function that wishes to use it. 