\section{statement.c File Reference}
\label{statement_8c}\index{statement.c@{statement.c}}
{\tt \#include $<$stdio.h$>$}\par
{\tt \#include $<$assert.h$>$}\par
{\tt \#include $<$string.h$>$}\par
{\tt \#include \char`\"{}defines.h\char`\"{}}\par
{\tt \#include \char`\"{}statement.h\char`\"{}}\par
{\tt \#include \char`\"{}expr.h\char`\"{}}\par
{\tt \#include \char`\"{}util.h\char`\"{}}\par
{\tt \#include \char`\"{}link.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
{\bf statement} $\ast$ {\bf statement\_\-create} ({\bf expression} $\ast$exp)
\begin{CompactList}\small\item\em Creates new statement structure.\item\end{CompactList}\item 
void {\bf statement\_\-db\_\-write} ({\bf statement} $\ast$stmt, FILE $\ast$ofile, char $\ast$scope)
\begin{CompactList}\small\item\em Writes specified statement to the specified output file.\item\end{CompactList}\item 
{\bf bool} {\bf statement\_\-db\_\-read} (char $\ast$$\ast$line, {\bf module} $\ast$curr\_\-mod)
\begin{CompactList}\small\item\em Reads in statement line from specified string and stores statement in specified module.\item\end{CompactList}\item 
void {\bf statement\_\-loopback} ({\bf statement} $\ast$stmt)
\begin{CompactList}\small\item\em Connects statement sequence to form a loop.\item\end{CompactList}\item 
void {\bf statement\_\-dealloc} ({\bf statement} $\ast$stmt)
\begin{CompactList}\small\item\em Deallocates statement memory and associated expression tree from the heap.\item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}


\begin{Desc}
\item[Author: ]\par
Trevor Williams ({\tt trevorw@charter.net}) \end{Desc}
\begin{Desc}
\item[Date: ]\par
5/1/2002

 Statements are used to indicate flow of execution for a given always or initial block. Each statement is assigned to exactly one expression tree and it contains a pointer to the next statement if its expression tree evaluates to TRUE (non-zero value) or FALSE (zero value). To minimize memory use, a statement  uses some of the unused bits in its root expression supplemental field instead of having its own supplemental field. There are two bits in the expression supplemental value that are only used by expressions: {\bf SUPPL\_\-LSB\_\-STMT\_\-HEAD} {\rm (p.\,\pageref{group__expr__suppl_a3})} and {\bf SUPPL\_\-LSB\_\-STMT\_\-STOP} {\rm (p.\,\pageref{group__expr__suppl_a4})}.

 The STMT\_\-HEAD bit indicates that this statement should be loaded into the pre-simulation statement queue if any of its expressions change value in the current timestep. To begin with, the first statement in the always/initial block has this bit set, all other statements have this bit cleared.

 The STMT\_\-STOP bit is used for CDD output. If a statement has this bit set, it will not traverse its next\_\-true or next\_\-false paths when outputting. This is necessary when statement paths merge back to the same path. If this bit was not used, the statements output after the merge would be output twice. Consider the following Verilog code snippet:\end{Desc}


\footnotesize\begin{verbatim} intial begin
        a = 0;
        if( a )
          b = 1;
        else
          b = 0;
        c = a | b;
 end
\end{verbatim}\normalsize 


 In this example there are five statements. They are the following:

\begin{enumerate}
\item 


\footnotesize\begin{verbatim}a = 0; 
\end{verbatim}\normalsize 
\item 


\footnotesize\begin{verbatim}if( a ) 
\end{verbatim}\normalsize 
\item 


\footnotesize\begin{verbatim}b = 1; 
\end{verbatim}\normalsize 
\item 


\footnotesize\begin{verbatim}b = 0; 
\end{verbatim}\normalsize 
\item 


\footnotesize\begin{verbatim}c = a | b; 
\end{verbatim}\normalsize 
\end{enumerate}


 Notice that the if statement has two paths. If a is TRUE, statement 3 is executed; otherwise, statement 4 is executed. Both statements 3 and 4 then merge to execute statement 5. If the entire statement tree were printed without a STOP bit, you can see that statement 5 would be output twice; once for the TRUE branch and once for the FALSE branch.

 To eliminate this redundancy, the STMT\_\-STOP bit is set on statement 4. The last statement of a FALSE path before merging always gets its STMT\_\-STOP bit set. The TRUE path should never get the STMT\_\-STOP bit set. Additionally, once a statement gets its STMT\_\-STOP bit set by the parser, this value must be maintained (never cleared).\begin{Desc}
\item[Cyclic Statement Trees]\par
 Many times a statement tree will \char`\"{}loopback\char`\"{} on itself. These statement trees are considered to be cyclic in nature and, as such, must have leaf statements of the statement tree tied to the first statement of the tree. The following Verilog constructs have cyclic behavior: {\tt always}, {\tt forever}, {\tt for}, {\tt repeat}, and {\tt while}.\end{Desc}
\begin{Desc}
\item[Traversing Statement Tree]\par
 Starting at the head statement, the value of the head statement is determined to be TRUE or FALSE. If the value is TRUE (non-zero), the next\_\-true path is taken. If the value is FALSE (zero), the next\_\-false path is taken. For statements that express an assignment (or other statements that do not branch), both the next\_\-true and next\_\-false paths point to the same statement. For statements that express a wait-for-event (ex. {\tt wait}, {\tt @}, etc.), the next\_\-true pointer will point to the next statement in the tree; however, the next\_\-false pointer will point to NULL. This NULL assignment indicates to the statement simulation engine that this statement will receive the STMT\_\-HEAD bit and the current statement tree is finished for this timestep.\end{Desc}


\subsection{Function Documentation}
\index{statement.c@{statement.c}!statement_create@{statement\_\-create}}
\index{statement_create@{statement\_\-create}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf statement}$\ast$ statement\_\-create ({\bf expression} $\ast$ {\em exp})}\label{statement_8c_a0}


Creates new statement structure.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
exp}]Pointer to root expression of expression tree for this statement.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Returns pointer to the newly created statement.\end{Desc}
Creates a new statement structure from heap memory and initializes it with the specified parameter information. \index{statement.c@{statement.c}!statement_db_read@{statement\_\-db\_\-read}}
\index{statement_db_read@{statement\_\-db\_\-read}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} statement\_\-db\_\-read (char $\ast$$\ast$ {\em line}, {\bf module} $\ast$ {\em curr\_\-mod})}\label{statement_8c_a2}


Reads in statement line from specified string and stores statement in specified module.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
line}]Pointer to current line of file being read. \item[{\em 
curr\_\-mod}]Pointer to current module.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Returns TRUE if the line is read without error; otherwise, returns FALSE.\end{Desc}
Reads in the contents of the statement from the specified line, creates a statement structure to hold the contents. \index{statement.c@{statement.c}!statement_db_write@{statement\_\-db\_\-write}}
\index{statement_db_write@{statement\_\-db\_\-write}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-db\_\-write ({\bf statement} $\ast$ {\em stmt}, FILE $\ast$ {\em ofile}, char $\ast$ {\em scope})}\label{statement_8c_a1}


Writes specified statement to the specified output file.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
stmt}]Pointer to statement to write out value. \item[{\em 
ofile}]Pointer to output file to write statement line to. \item[{\em 
scope}]Scope of parent module which contains the specified statement.\end{description}
\end{Desc}
Recursively writes the contents of the specified statement tree (and its associated expression trees to the specified output stream. \index{statement.c@{statement.c}!statement_dealloc@{statement\_\-dealloc}}
\index{statement_dealloc@{statement\_\-dealloc}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-dealloc ({\bf statement} $\ast$ {\em stmt})}\label{statement_8c_a4}


Deallocates statement memory and associated expression tree from the heap.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
stmt}]Pointer to statement to deallocate.\end{description}
\end{Desc}
Deallocates specified statement from heap memory. First remove expression tree of this statement. Second, remove all statements following this statement. Finally, remove the specified statement itself. Since statements can be circular in nature, we will not remove a statement that has its expression tree already deallocated. This will prevent this function from getting into an infinite loop (or stack overflow since this function is recursive). \index{statement.c@{statement.c}!statement_loopback@{statement\_\-loopback}}
\index{statement_loopback@{statement\_\-loopback}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-loopback ({\bf statement} $\ast$ {\em stmt})}\label{statement_8c_a3}


Connects statement sequence to form a loop.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
stmt}]Pointer to statement sequence to connect ends for loopback.\end{description}
\end{Desc}
Traverses the specified stmt sequence (assumes that stmt is the statement at the top of the sequence). When it reaches a statement that has both next\_\-true and next\_\-false set to NULL, sets next\_\-true and next\_\-false of that statement to point to the top of the sequence. This will cause the statement to have a loopback effect. 