\section{sim.c File Reference}
\label{sim_8c}\index{sim.c@{sim.c}}
{\tt \#include $<$assert.h$>$}\par
{\tt \#include \char`\"{}defines.h\char`\"{}}\par
{\tt \#include \char`\"{}sim.h\char`\"{}}\par
{\tt \#include \char`\"{}expr.h\char`\"{}}\par
{\tt \#include \char`\"{}vector.h\char`\"{}}\par
{\tt \#include \char`\"{}iter.h\char`\"{}}\par
{\tt \#include \char`\"{}link.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
void {\bf sim\_\-expr\_\-changed} ({\bf expression} $\ast$expr)
\begin{CompactList}\small\item\em Adds specified expression's statement to pre-simulation statement queue.\item\end{CompactList}\item 
void {\bf sim\_\-add\_\-stmt\_\-to\_\-queue} ({\bf statement} $\ast$stmt)
\begin{CompactList}\small\item\em Adds specified statement to pre-simulation statement queue.\item\end{CompactList}\item 
void {\bf sim\_\-add\_\-statics} ()
\begin{CompactList}\small\item\em Adds static expression values to initial simulator.\item\end{CompactList}\item 
void {\bf sim\_\-expression} ({\bf expression} $\ast$expr)
\item 
{\bf statement} $\ast$ {\bf sim\_\-statement} ({\bf statement} $\ast$head\_\-stmt)
\item 
void {\bf sim\_\-simulate} ()
\begin{CompactList}\small\item\em Simulates current timestep.\item\end{CompactList}\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
{\bf nibble} {\bf or\_\-optab} [16]
\item 
{\bf exp\_\-link} $\ast$ {\bf static\_\-expr\_\-head} = NULL
\item 
{\bf exp\_\-link} $\ast$ {\bf static\_\-expr\_\-tail} = NULL
\item 
{\bf stmt\_\-link} $\ast$ {\bf presim\_\-stmt\_\-head} = NULL
\item 
{\bf stmt\_\-link} $\ast$ {\bf presim\_\-stmt\_\-tail} = NULL
\end{CompactItemize}


\subsection{Detailed Description}


\begin{Desc}
\item[Author: ]\par
Trevor Williams ({\tt trevorw@charter.net}) \end{Desc}
\begin{Desc}
\item[Date: ]\par
6/20/2002

 The simulation engine is made up of three parts:\begin{enumerate}
\item 
pre-simulation statement queue\item 
statement simulation engine\item 
expression simulation engine\end{enumerate}
\end{Desc}


 The operation of the simulation engine is as follows. When a signal is found in the VCD file, the expressions to which it is a part of the RHS are looked up in the design tree. The expression tree is then parsed from the expression to the root, setting the {\bf SUPPL\_\-LSB\_\-LEFT\_\-CHANGED} {\rm (p.\,\pageref{group__expr__suppl_a9})} or {\bf SUPPL\_\-LSB\_\-RIGHT\_\-CHANGED} {\rm (p.\,\pageref{group__expr__suppl_a10})} as it  makes its way to the root. When at the root expression, the {\bf SUPPL\_\-LSB\_\-STMT\_\-HEAD} {\rm (p.\,\pageref{group__expr__suppl_a4})}  bit is interrogated. If this bit is a 1, the expression's statement is loaded  into the pre-simulation statement queue. If the bit is a 0, no further action is  taken.

 Once the timestep marker has been set, the simulate function is called. The  statement located at the head of the queue is placed into the statement simulation  engine and the head pointer is set to point to the next statement in the queue.  The head statement is continually taken until the pre-simulation statement queue  is empty. This signifies that the timestep has been completed.

 When a statement is placed into the statement simulation engine, the {\bf SUPPL\_\-LSB\_\-STMT\_\-HEAD} {\rm (p.\,\pageref{group__expr__suppl_a4})}  bit is cleared in the root expression. Additionally, the root expression pointed to by  the statement is interrogated to see if the {\bf SUPPL\_\-LSB\_\-LEFT\_\-CHANGED} {\rm (p.\,\pageref{group__expr__suppl_a9})} or {\bf SUPPL\_\-LSB\_\-RIGHT\_\-CHANGED} {\rm (p.\,\pageref{group__expr__suppl_a10})}  bits are set. If one or both of the bits are found to be set, the root expression  is placed into the expression simulation engine for further processing. When the  statement's expression has completed its simulation, the value of the root expression  is used to determine if the next\_\-true or next\_\-false path will be taken. If the value  of the root expression is true, the next\_\-true statement is loaded into the statement  simulation engine. If the value of the root expression is false and the next\_\-false  pointer is NULL, this signifies that the current statement tree has completed for this  timestep. At this point, the current statement will set the {\bf SUPPL\_\-LSB\_\-STMT\_\-HEAD} {\rm (p.\,\pageref{group__expr__suppl_a4})} bit in  its root expression and is removed from the statement simulation engine. The next statement  at the head of the pre-simulation statement queue is then loaded into the statement  simulation engine. If next\_\-false statement is not NULL, it is loaded into the statement  simulation engine and work is done on that statement.

 When a root expression is placed into the expression simulation engine, the tree is traversed, following the paths that have set {\bf SUPPL\_\-LSB\_\-LEFT\_\-CHANGED} {\rm (p.\,\pageref{group__expr__suppl_a9})} or  {\bf SUPPL\_\-LSB\_\-RIGHT\_\-CHANGED} {\rm (p.\,\pageref{group__expr__suppl_a10})} bits set. Each expression tree is traversed depth first. When an  expression is reached that does not have either of these bits set, we have reached the expression whose value has changed. When this expression is found, it is evaluated and the resulting value is stored into its value vector. Once this has occurred, the parent expression checks to see if the other child expression has changed value. If so, that child expression's tree is traversed. Once both child expressions contain the current value for the current timestep, the parent expression evaluates its expression with the values of its children and clears both the {\bf SUPPL\_\-LSB\_\-LEFT\_\-CHANGED} {\rm (p.\,\pageref{group__expr__suppl_a9})} and {\bf SUPPL\_\-LSB\_\-RIGHT\_\-CHANGED} {\rm (p.\,\pageref{group__expr__suppl_a10})} bits to indicate that both children were evaluated. The resulting value is stored into the current expression's value vector and the parent expression of the current expression is worked on. This evaluation process continues until the root expression of the tree has been evaluated. At this point the expression tree is removed from the expression simulation engine and the associated statement worked on by the statement simulation engine as specified above.



\subsection{Function Documentation}
\index{sim.c@{sim.c}!sim_add_statics@{sim\_\-add\_\-statics}}
\index{sim_add_statics@{sim\_\-add\_\-statics}!sim.c@{sim.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void sim\_\-add\_\-statics ()}\label{sim_8c_a7}


Adds static expression values to initial simulator.

Iterates through static expression list and causes the simulator to evaluate these expressions at simulation time. \index{sim.c@{sim.c}!sim_add_stmt_to_queue@{sim\_\-add\_\-stmt\_\-to\_\-queue}}
\index{sim_add_stmt_to_queue@{sim\_\-add\_\-stmt\_\-to\_\-queue}!sim.c@{sim.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void sim\_\-add\_\-stmt\_\-to\_\-queue ({\bf statement} $\ast$ {\em stmt})}\label{sim_8c_a6}


Adds specified statement to pre-simulation statement queue.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
stmt}]Pointer to statement to add to queue.\end{description}
\end{Desc}
Checks STMT\_\-HEAD bit of specified statement. If this is set to 1, adds this statement to the presimulation statement queue; otherwise, it does nothing with the statement \index{sim.c@{sim.c}!sim_expr_changed@{sim\_\-expr\_\-changed}}
\index{sim_expr_changed@{sim\_\-expr\_\-changed}!sim.c@{sim.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void sim\_\-expr\_\-changed ({\bf expression} $\ast$ {\em expr})}\label{sim_8c_a5}


Adds specified expression's statement to pre-simulation statement queue.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
expr}]Pointer to expression that contains a changed signal value.\end{description}
\end{Desc}
Traverses up expression tree pointed to by leaf node expr, setting the CHANGED bits as it reaches the root expression. When the root expression is found, the statement pointed to by the root's parent pointer is added to the pre-simulation statement queue for simulation at the end of the timestep. If, upon traversing the tree, an expression is found to already be have a CHANGED bit set, we know that the statement has already been added, so stop here and do not add the statement again. \index{sim.c@{sim.c}!sim_expression@{sim\_\-expression}}
\index{sim_expression@{sim\_\-expression}!sim.c@{sim.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void sim\_\-expression ({\bf expression} $\ast$ {\em expr})}\label{sim_8c_a8}


\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
expr}]Pointer to expression to simulate.\end{description}
\end{Desc}
Recursively traverses specified expression tree, following the {\bf SUPPL\_\-LSB\_\-LEFT\_\-CHANGED} {\rm (p.\,\pageref{group__expr__suppl_a9})}  and {\bf SUPPL\_\-LSB\_\-RIGHT\_\-CHANGED} {\rm (p.\,\pageref{group__expr__suppl_a10})} bits in the supplemental field. Once an expression is found that has neither bit set, perform the expression operation and move back up the tree. Once both left and right children have calculated values, perform the expression operation for the current expression, clear both changed bits and return. \index{sim.c@{sim.c}!sim_simulate@{sim\_\-simulate}}
\index{sim_simulate@{sim\_\-simulate}!sim.c@{sim.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void sim\_\-simulate ()}\label{sim_8c_a10}


Simulates current timestep.

This function is the heart of the simulation engine. It is called by the {\bf db\_\-do\_\-timestep}() {\rm (p.\,\pageref{db_8c_a44})} function in {\bf db.c} and moves the statements and expressions into the appropriate simulation functions. See above explanation on this procedure. \index{sim.c@{sim.c}!sim_statement@{sim\_\-statement}}
\index{sim_statement@{sim\_\-statement}!sim.c@{sim.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf statement}$\ast$ sim\_\-statement ({\bf statement} $\ast$ {\em head\_\-stmt})}\label{sim_8c_a9}


\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
head\_\-stmt}]Pointer to head statement to simulate.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Returns a pointer to the first statement to execute in the next timestep\end{Desc}
Performs statement simulation as described above. Calls expression simulator if the associated root expression is specified that signals have changed value within it. Continues to run for current statement tree until statement tree hits a wait-for-event condition (or we reach the end of a simulation tree). 

\subsection{Variable Documentation}
\index{sim.c@{sim.c}!or_optab@{or\_\-optab}}
\index{or_optab@{or\_\-optab}!sim.c@{sim.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nibble} or\_\-optab[16] ()}\label{sim_8c_a0}


OR operation table \index{sim.c@{sim.c}!presim_stmt_head@{presim\_\-stmt\_\-head}}
\index{presim_stmt_head@{presim\_\-stmt\_\-head}!sim.c@{sim.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf stmt\_\-link}$\ast$ presim\_\-stmt\_\-head = NULL}\label{sim_8c_a3}


\index{sim.c@{sim.c}!presim_stmt_tail@{presim\_\-stmt\_\-tail}}
\index{presim_stmt_tail@{presim\_\-stmt\_\-tail}!sim.c@{sim.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf stmt\_\-link}$\ast$ presim\_\-stmt\_\-tail = NULL}\label{sim_8c_a4}


\index{sim.c@{sim.c}!static_expr_head@{static\_\-expr\_\-head}}
\index{static_expr_head@{static\_\-expr\_\-head}!sim.c@{sim.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf exp\_\-link}$\ast$ static\_\-expr\_\-head = NULL}\label{sim_8c_a1}


\index{sim.c@{sim.c}!static_expr_tail@{static\_\-expr\_\-tail}}
\index{static_expr_tail@{static\_\-expr\_\-tail}!sim.c@{sim.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf exp\_\-link}$\ast$ static\_\-expr\_\-tail = NULL}\label{sim_8c_a2}


