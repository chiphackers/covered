\section{expr.c File Reference}
\label{expr_8c}\index{expr.c@{expr.c}}
{\tt \#include $<$stdio.h$>$}\par
{\tt \#include $<$stdlib.h$>$}\par
{\tt \#include $<$assert.h$>$}\par
{\tt \#include \char`\"{}defines.h\char`\"{}}\par
{\tt \#include \char`\"{}expr.h\char`\"{}}\par
{\tt \#include \char`\"{}link.h\char`\"{}}\par
{\tt \#include \char`\"{}vector.h\char`\"{}}\par
{\tt \#include \char`\"{}binding.h\char`\"{}}\par
{\tt \#include \char`\"{}util.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
void {\bf expression\_\-create\_\-value} ({\bf expression} $\ast$exp, int width, int lsb)
\begin{CompactList}\small\item\em Creates an expression value and initializes it.\item\end{CompactList}\item 
{\bf expression} $\ast$ {\bf expression\_\-create} ({\bf expression} $\ast$right, {\bf expression} $\ast$left, int op, int id, int line)
\begin{CompactList}\small\item\em Creates new expression.\item\end{CompactList}\item 
void {\bf expression\_\-merge} ({\bf expression} $\ast$base, {\bf expression} $\ast$in)
\begin{CompactList}\small\item\em Merges two expressions and stores result in base expression.\item\end{CompactList}\item 
int {\bf expression\_\-get\_\-id} ({\bf expression} $\ast$expr)
\begin{CompactList}\small\item\em Returns expression ID of this expression.\item\end{CompactList}\item 
void {\bf expression\_\-db\_\-write} ({\bf expression} $\ast$expr, FILE $\ast${\bf file}, char $\ast$scope)
\begin{CompactList}\small\item\em Writes this expression to the specified database file.\item\end{CompactList}\item 
{\bf bool} {\bf expression\_\-db\_\-read} (char $\ast$$\ast$line, {\bf module} $\ast$curr\_\-mod)
\begin{CompactList}\small\item\em Reads current line of specified file and parses for expression information.\item\end{CompactList}\item 
void {\bf expression\_\-display} ({\bf expression} $\ast$expr)
\begin{CompactList}\small\item\em Displays the specified expression information.\item\end{CompactList}\item 
void {\bf expression\_\-operate} ({\bf expression} $\ast$expr)
\begin{CompactList}\small\item\em Performs operation specified by parameter expression.\item\end{CompactList}\item 
int {\bf expression\_\-bit\_\-value} ({\bf expression} $\ast$expr)
\begin{CompactList}\small\item\em Returns a compressed, 1-bit representation of the value after a unary OR.\item\end{CompactList}\item 
void {\bf expression\_\-dealloc} ({\bf expression} $\ast$expr, {\bf bool} exp\_\-only)
\begin{CompactList}\small\item\em Deallocates memory used for expression.\item\end{CompactList}\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
{\bf nibble} {\bf xor\_\-optab} [16]
\item 
{\bf nibble} {\bf and\_\-optab} [16]
\item 
{\bf nibble} {\bf or\_\-optab} [16]
\item 
{\bf nibble} {\bf nand\_\-optab} [16]
\item 
{\bf nibble} {\bf nor\_\-optab} [16]
\item 
{\bf nibble} {\bf nxor\_\-optab} [16]
\item 
int {\bf curr\_\-sim\_\-time}
\end{CompactItemize}


\subsection{Detailed Description}


\begin{Desc}
\item[Author: ]\par
Trevor Williams ({\tt trevorw@charter.net}) \end{Desc}
\begin{Desc}
\item[Date: ]\par
12/1/2001\end{Desc}


\subsection{Function Documentation}
\index{expr.c@{expr.c}!expression_bit_value@{expression\_\-bit\_\-value}}
\index{expression_bit_value@{expression\_\-bit\_\-value}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int expression\_\-bit\_\-value ({\bf expression} $\ast$ {\em expr})}\label{expr_8c_a15}


Returns a compressed, 1-bit representation of the value after a unary OR.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
expr}]Pointer to expression to evaluate.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Returns the value of the expression after being compressed to 1 bit via a unary OR.\end{Desc}
Returns a value of 1 if the specified expression contains at least one 1 value and no X or Z values in its bits. It accomplishes this by performing a unary  OR operation on the specified expression value and testing bit 0 of the result. \index{expr.c@{expr.c}!expression_create@{expression\_\-create}}
\index{expression_create@{expression\_\-create}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf expression}$\ast$ expression\_\-create ({\bf expression} $\ast$ {\em right}, {\bf expression} $\ast$ {\em left}, int {\em op}, int {\em id}, int {\em line})}\label{expr_8c_a8}


Creates new expression.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
right}]Pointer to expression on right. \item[{\em 
left}]Pointer to expression on left. \item[{\em 
op}]Operation to perform for this expression. \item[{\em 
id}]ID for this expression as determined by the parent. \item[{\em 
line}]Line number this expression is on.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Returns pointer to newly created expression.\end{Desc}
Creates a new expression from heap memory and initializes its values for usage. Right and left expressions need to be created before this function is called. \index{expr.c@{expr.c}!expression_create_value@{expression\_\-create\_\-value}}
\index{expression_create_value@{expression\_\-create\_\-value}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void expression\_\-create\_\-value ({\bf expression} $\ast$ {\em exp}, int {\em width}, int {\em lsb})}\label{expr_8c_a7}


Creates an expression value and initializes it.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
exp}]Pointer to expression to add value to. \item[{\em 
width}]Width of value to create. \item[{\em 
lsb}]Least significant value of value field.\end{description}
\end{Desc}
Creates a value vector that is large enough to store width number of bits in value and sets the specified expression value to this value. This function should be called by either the expression\_\-create function, the bind function, or the signal db\_\-read function. \index{expr.c@{expr.c}!expression_db_read@{expression\_\-db\_\-read}}
\index{expression_db_read@{expression\_\-db\_\-read}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} expression\_\-db\_\-read (char $\ast$$\ast$ {\em line}, {\bf module} $\ast$ {\em curr\_\-mod})}\label{expr_8c_a12}


Reads current line of specified file and parses for expression information.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
line}]String containing database line to read information from. \item[{\em 
curr\_\-mod}]Pointer to current module that instantiates this expression.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Returns TRUE if parsing successful; otherwise, returns FALSE.\end{Desc}
Reads in the specified expression information, creates new expression from heap, populates the expression with specified information from file and  returns that value in the specified expression pointer. If all is  successful, returns TRUE; otherwise, returns FALSE. \index{expr.c@{expr.c}!expression_db_write@{expression\_\-db\_\-write}}
\index{expression_db_write@{expression\_\-db\_\-write}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void expression\_\-db\_\-write ({\bf expression} $\ast$ {\em expr}, FILE $\ast$ {\em file}, char $\ast$ {\em scope})}\label{expr_8c_a11}


Writes this expression to the specified database file.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
expr}]Pointer to expression to write to database file. \item[{\em 
file}]Pointer to database file to write to. \item[{\em 
scope}]Name of Verilog hierarchical scope for this expression.\end{description}
\end{Desc}
This function recursively displays the expression information for the specified expression tree to the coverage database specified by file. \index{expr.c@{expr.c}!expression_dealloc@{expression\_\-dealloc}}
\index{expression_dealloc@{expression\_\-dealloc}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void expression\_\-dealloc ({\bf expression} $\ast$ {\em expr}, {\bf bool} {\em exp\_\-only})}\label{expr_8c_a16}


Deallocates memory used for expression.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
expr}]Pointer to root expression to deallocate. \item[{\em 
exp\_\-only}]Removes only the specified expression and not its children.\end{description}
\end{Desc}
Deallocates all heap memory allocated with the malloc routine. \index{expr.c@{expr.c}!expression_display@{expression\_\-display}}
\index{expression_display@{expression\_\-display}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void expression\_\-display ({\bf expression} $\ast$ {\em expr})}\label{expr_8c_a13}


Displays the specified expression information.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
expr}]Pointer to expression to display.\end{description}
\end{Desc}
Displays contents of the specified expression to standard output. This function is called by the module\_\-display function. \index{expr.c@{expr.c}!expression_get_id@{expression\_\-get\_\-id}}
\index{expression_get_id@{expression\_\-get\_\-id}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int expression\_\-get\_\-id ({\bf expression} $\ast$ {\em expr})}\label{expr_8c_a10}


Returns expression ID of this expression.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
expr}]Pointer to expression to get ID from. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Returns expression ID for this expression.\end{Desc}
If specified expression is non-NULL, return expression ID of this expression; otherwise, return a value of 0 to indicate that this is a leaf node. \index{expr.c@{expr.c}!expression_merge@{expression\_\-merge}}
\index{expression_merge@{expression\_\-merge}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void expression\_\-merge ({\bf expression} $\ast$ {\em base}, {\bf expression} $\ast$ {\em in})}\label{expr_8c_a9}


Merges two expressions and stores result in base expression.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
base}]Expression to merge data into. \item[{\em 
in}]Expression to get merged into base expression.\end{description}
\end{Desc}
Merges contents of the base and in expressions and places the result into the base expression. If the two expressions given are not the same (IDs, op, and/or line position differ) we know that the database files being merged  were not created from the same design; therefore, display an error message  to the user in this case. If both expressions are the same, perform the  merge. \index{expr.c@{expr.c}!expression_operate@{expression\_\-operate}}
\index{expression_operate@{expression\_\-operate}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void expression\_\-operate ({\bf expression} $\ast$ {\em expr})}\label{expr_8c_a14}


Performs operation specified by parameter expression.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
expr}]Pointer to expression to set value to.\end{description}
\end{Desc}
Performs expression operation. This function must only be run after its left and right expressions have been calculated during this clock period. Sets the value of the operation in its own vector value and updates the suppl nibble as necessary. 

\subsection{Variable Documentation}
\index{expr.c@{expr.c}!and_optab@{and\_\-optab}}
\index{and_optab@{and\_\-optab}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nibble} and\_\-optab[16] ()}\label{expr_8c_a1}


AND operation table \index{expr.c@{expr.c}!curr_sim_time@{curr\_\-sim\_\-time}}
\index{curr_sim_time@{curr\_\-sim\_\-time}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int curr\_\-sim\_\-time ()}\label{expr_8c_a6}


This static value contains the current simulation time which is specified by the db\_\-do\_\-timestep function. It is used for calculating delay expressions in the simulation engine. \index{expr.c@{expr.c}!nand_optab@{nand\_\-optab}}
\index{nand_optab@{nand\_\-optab}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nibble} nand\_\-optab[16] ()}\label{expr_8c_a3}


NAND operation table \index{expr.c@{expr.c}!nor_optab@{nor\_\-optab}}
\index{nor_optab@{nor\_\-optab}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nibble} nor\_\-optab[16] ()}\label{expr_8c_a4}


NOR operation table \index{expr.c@{expr.c}!nxor_optab@{nxor\_\-optab}}
\index{nxor_optab@{nxor\_\-optab}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nibble} nxor\_\-optab[16] ()}\label{expr_8c_a5}


NXOR operation table \index{expr.c@{expr.c}!or_optab@{or\_\-optab}}
\index{or_optab@{or\_\-optab}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nibble} or\_\-optab[16]}\label{expr_8c_a2}


\index{expr.c@{expr.c}!xor_optab@{xor\_\-optab}}
\index{xor_optab@{xor\_\-optab}!expr.c@{expr.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nibble} xor\_\-optab[16] ()}\label{expr_8c_a0}


XOR operation table 