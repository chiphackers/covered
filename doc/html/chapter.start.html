<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 7. Getting Started</title><link rel="stylesheet" href="covered.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.71.1"><link rel="start" href="index.html" title="Covered"><link rel="up" href="part.command.line.usage.html" title="Part III. Command-line Usage"><link rel="prev" href="part.command.line.usage.html" title="Part III. Command-line Usage"><link rel="next" href="chapter.using.html" title="Chapter 8. Using Covered"></head><body bgcolor="#dfeef8" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 7. Getting Started</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="part.command.line.usage.html"><img src="img/prev.gif" alt="Prev"></a> </td><th width="60%" align="center">Part III. Command-line Usage</th><td width="20%" align="right"> <a accesskey="n" href="chapter.using.html"><img src="img/next.gif" alt="Next"></a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="chapter.start"></a>Chapter 7. Getting Started</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="chapter.start.html#section.start.methods">7.1. Methods for scoring the design</a></span></dt><dd><dl><dt><span class="sect2"><a href="chapter.start.html#section.start.methods.dumppost">Post-processing VCD/LXT2 dumpfiles</a></span></dt><dt><span class="sect2"><a href="chapter.start.html#section.start.methods.dumpco">Co-processing VCD/LXT2 dumpfiles via FIFO</a></span></dt><dt><span class="sect2"><a href="chapter.start.html#section.start.methods.vpi">Using the VPI interface to gather coverage information</a></span></dt></dl></dd><dt><span class="sect1"><a href="chapter.start.html#section.start.dump">7.2. What is needed for dumpfile scoring?</a></span></dt><dd><dl><dt><span class="sect2"><a href="chapter.start.html#section.start.dump.vcd">Creating a VCD dumpfile</a></span></dt><dt><span class="sect2"><a href="chapter.start.html#section.start.dump.lxt">Creating an LXT2 dumpfile</a></span></dt></dl></dd><dt><span class="sect1"><a href="chapter.start.html#section.start.vpi">7.3. What is needed for VPI scoring?</a></span></dt><dd><dl><dt><span class="sect2"><a href="chapter.start.html#section.start.vpi.iv">Compiling for Icarus Verilog</a></span></dt><dt><span class="sect2"><a href="chapter.start.html#section.start.vpi.cver">Compiling for Cver</a></span></dt><dt><span class="sect2"><a href="chapter.start.html#section.start.vpi.vcs">Compiling for VCS</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="section.start.methods"></a>7.1. Methods for scoring the design</h2></div></div></div><p>
      Before you are ready to being scoring, merging and generating coverage reports from the design, you will first need to 
      decide whether you want to post-process VCD/LXT2 -formatted dumpfiles generated from simulation, co-process VCD/LXT2 -formatted
      dumpfiles using two processes (one for the simulation process and one for the Covered process) and a Unix FIFO, or whether 
      you want to accummulate coverage information alongside the simulator using the simulator's VPI interface. There are advantages and 
      disadvantages to these methods, so select the method that will best work for you.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.start.methods.dumppost"></a>Post-processing VCD/LXT2 dumpfiles</h3></div></div></div><p>
        Generating post-process coverage information from VCD/LXT2 -formatted dumpfiles requires three steps:
      </p><p>
        </p><div class="orderedlist"><ol type="1"><li><p>Compile the simulator to dump in the specified format.</p></li><li><p>Run the simulation.</p></li><li><p>Run Covered's score command using the dumpfile as input along with the design.</p></li></ol></div><p>
      </p><p>
        Performing these steps will generate the needed CDD file that can be used for merging or reporting. 
        The advantages to this approach is that the steps are fairly simple and are compiler/simulator -independent. However, 
        there are two main drawbacks. First, compiling with dumping enabled often slows simulation by some significant factor. 
        Second, the dumpfiles generated from simulation can often be quite large (especially for VCD dumping), consuming a lot 
        of disk space. Additionally, if your simulator dumps in a format different from VCD or LXT2, you will need to perform 
        an additional step in transforming the original dumpfile into one of these formats. This is often a time-consuming task 
        if the design and/or dumpfile is significantly large. If you are generating lots of dumpfiles for coverage (say from 
        running a regression), the amount of disk space needed to store these files can be tremendous, making this approach 
        almost not feasible.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.start.methods.dumpco"></a>Co-processing VCD/LXT2 dumpfiles via FIFO</h3></div></div></div><p>
        Generating co-process coverage information from VCD/LXT2 -formatted dumpfiles requires four steps:
      </p><p>
        </p><div class="orderedlist"><ol type="1"><li><p>Compile the simulator to dump in the specified format.</p></li><li><p>Create a Unix FIFO via the <code class="code">mkfifo <span class="emphasis"><em>fifoname</em></span></code> command.</p></li><li><p>Create an empty CDD file for the design using Covered's score command.</p></li><li><p>
              Run the simulation and Covered's score command simultaneously.  The following is an example of a testbench and
              command-line commands:
            </p><p>
              </p><div class="example"><a name="example.start.methods.dumpco"></a><p class="title"><b>Example 7.1. Running Covered Alongside a Simulation Process Using a Unix FIFO to Pass Dumpfile Information</b></p><div class="example-contents"><pre class="programlisting">
  # Module listing for file "test.v"
  module tb;
    ...
    initial begin
            $dumpfile( "dump_fifo" );
            $dumpvars( 0, tb );
            ...
    end
    ...
  endmodule
  
  # Command-line output
  &gt; mkfifo dump_fifo
  &gt; vcs test.v
  &gt; covered score -t tb -v test.v -o test.cdd
  &gt; ./simv &amp;
  &gt; covered score -cdd test.cdd -vcd dump_fifo
                </pre></div></div><p><br class="example-break">
            </p></li></ol></div><p>
      </p><p>
        The end result of these steps is the same CDD file that results from using the dumpfile method described above.
        The primary advantages of this approach are that no dumpfiles are actually created, saving on disk space, and
        it does not significantly slow down the simulation process.  Because both simulation and coverage scoring
        occur simultaneously, there should be a wall clock time improvement with this method.
      </p><p>
        The drawbacks of this approach are basically that the time improvement won't be significant if you are running
        on a single processor/core system and that it is restricted to machines that support the Unix fifo (this may
        not be an actual restriction, however).
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.start.methods.vpi"></a>Using the VPI interface to gather coverage information</h3></div></div></div><p>
        Generating coverage information using the VPI interface of the simulator requires three main steps:
      </p><p>
        </p><div class="orderedlist"><ol type="1"><li><p>
              Create a base CDD file from the design along with a top-level Verilog module and PLI table file (this second 
              file is needed for the commercial VCS compiler).
            </p></li><li><p>
              Compile the simulator using the Covered VPI module (or shared object).
            </p></li><li><p>
              Run the simulation.
            </p></li></ol></div><p>
      </p><p>
        The end result of these steps is the same CDD file that results from using the dumpfile method described 
        above. The primary advantage of this approach is that no dumpfiles are required, saving on disk space and dumpfile 
        processing time. The drawbacks of this approach are the following:
      </p><p>
        </p><div class="orderedlist"><ol type="1"><li><p>
              Simulation runs much slower using the VPI and Covered (most likely slower than creating dumpfiles from the 
              simulator).
            </p></li><li><p>
              Covered VPI modules are only available for certain compilers (Icarus Verilog, Cver and VCS currently); however, 
              adding support for other compilers should not be a difficult thing to do.
            </p></li><li><p>
              The VPI modules will only work for compilers that support the VPI interface (a Verilog-2001 feature).
            </p></li></ol></div><p>
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="section.start.dump"></a>7.2. What is needed for dumpfile scoring?</h2></div></div></div><p>
      Before Covered can be invoked for dumpfile scoring, you must have a simulatable Verilog design and a VCD or LXT2 dumpfile 
      containing information from a simulation run of the design that dumps the module(s) that you want to check for coverage. 
      The VCD dumpfile style was chosen due to its universal support by Verilog simulators while the LXT2 dumpfile style was 
      chosen due to its compactness and growing support by other open source simulators and dumpfile readers. Once you have 
      these two parts, you are ready to begin generating coverage results.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.start.dump.vcd"></a>Creating a VCD dumpfile</h3></div></div></div><p>
        In Verilog, the way that you create the VCD dumpfile is by using two types of Verilog system calls (1) $dumpfile and 
        (2) $dumpvars. The following example shows how to create and generate a dumpfile called "test.vcd" that will dump the 
        submodule called "foo".
      </p><p>
        </p><div class="example"><a name="example.start.dump"></a><p class="title"><b>Example 7.2. Verilog Code to Generate a VCD Dumpfile</b></p><div class="example-contents"><pre class="programlisting">
  module test;

    initial begin
      $dumpfile( "test.vcd" );
      $dumpvars( 1, test.foo );
    end

    foo_mod foo();

  endmodule

  module foo_mod;

    ...

  endmodule
          </pre></div></div><p><br class="example-break">
      </p><p>
        The $dumpfile system call takes in one parameter that is a string of the name of the dumpfile to create, in this case 
        the dumpfile we want to create is called "test.foo". The purpose of this function to create the file (open it for 
        writing) and outputs some initialization information to the file.
      </p><p>
        The $dumpvars system call takes in two parameters. The first is the number of levels of hierarchy that you want to 
        dump. In the example, we want to only dump the module instance called "foo" which is why the dump level was set to 1. 
        To dump foo and the level of submodules just beneath it, you would set the dump level to 2 and so on. To dump a module 
        and all submodules beneath it, set the dump level value to 0 (this means the level specified and all levels below it). 
        The second parameter is a Verilog hierarchical reference to the top-level module instance that you want to dump.
      </p><p>
        The $dumpfile system call may only be called once within a Verilog design. Typically, it is called in the top-most 
        level of the design (or testbench as it is commonly referred to as); however, the language allows you to call it from 
        anywhere in your design as long as it precedes any calls to $dumpvars.
      </p><p>
        The $dumpvars system call may be called as many times as necessary to dump the Verilog that you need. For example, if 
        you want to get coverage results for several modules scattered around the design, you may make several $dumpvars calls 
        to dump exactly those modules that you want to see coverage for.
      </p><p>
        For the most part, that is about all there is to creating VCD dumpfiles for the design. All you need to do is run a 
        simulation with these system calls in it and a dumpfile will be generated for that run. Once you have this file, you 
        are ready to see if your design is Covered!
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.start.dump.lxt"></a>Creating an LXT2 dumpfile</h3></div></div></div><p>
        An LXT2 dumpfile can be created in several different ways depending on the Verilog simulation tool that you are using. If 
        you are using the <a href="http://www.icarus.com/eda/verilog" target="_top">Icarus Verilog</a> open source simulator, you can 
        simply generate an LXT2-style dumpfile by specifying the -lxt2 option to the simulator command-line. For example, if you 
        had a file called "foo.v" that contained the same $dumpfile and $dumpvars commands used for VCD dumping and compiled it 
        with Icarus Verilog into a VVP file called "a.out", you could cause Icarus Verilog to generate an LXT2 dumpfile (instead 
        of a VCD dumpfile by calling "vvp a.out -lxt2". This will cause an LXT2 style dumpfile instead of the standard VCD style 
        dumpfile.
      </p><p>
        You can also transform many different dumpfile formats into an LXT2 style dumpfile with the helper programs that come with 
        the <a href="http://home.nc.rr.com/gtkwave/" target="_top">GtkWave</a> waveform viewer.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="section.start.vpi"></a>7.3. What is needed for VPI scoring?</h2></div></div></div><p>
      After Covered has been configured and built to include the creation of a VPI loadable module or shared object file (see 
      <a href="chapter.installation.html#section.installation.configuring" title="6.3. Configuring the build">Section 6.3, &#8220;Configuring the build&#8221;</a> for details), Covered is capable of scoring during a simulation run by using the VPI 
      (Verilog Procedural Interface) access mechanism. This is done by loading the Covered VPI module (or shared object) into the 
      simulator executable prior to running (depending on the simulator being used). The following steps should be taken to create 
      a scored CDD file using this method.
    </p><p>
      </p><div class="orderedlist"><ol type="1"><li><p>
            Create the Verilog file that will be compiled as a top-level module in the design (alongside the actual top-level(s)).
          </p><p>
            This is done by running the score command with the -vpi option. The following example command-line shows how this step 
            is done, creating a file called "covered_vpi.v".
          </p><p>
            <code class="code">&gt; covered score -t top -vpi</code>
          </p></li><li><p>
            Compile the simulator executable, including the previously generated file and the Covered VPI module. See the compile 
            instructions for the Icarus Verilog, Cver or VCS simulators below.
          </p></li><li><p>
            Run the simulation. Once simulation is complete, the resulting CDD file will be a completely scored database, ready to be 
            merged with other CDD files from the same design or reported on.
          </p></li></ol></div><p>
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.start.vpi.iv"></a>Compiling for Icarus Verilog</h3></div></div></div><p>
        If you are compiling an Icarus Verilog simulation, simply add 
        <span class="bold"><strong><code class="code">-m /usr/local/libexec/covered.vpi covered_vpi.v</code></strong></span> to the command-line.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.start.vpi.cver"></a>Compiling for Cver</h3></div></div></div><p>
        If you are compiling a Cver simulation, simply add 
        <span class="bold"><strong><code class="code">+loadvpi=/usr/local/libexec/covered.cver.so:vpi_compat_bootstrap covered_vpi.v</code></strong></span> 
        to the command-line.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.start.vpi.vcs"></a>Compiling for VCS</h3></div></div></div><p>
        If you are compiling a VCS simulation, simply add 
        <span class="bold"><strong><code class="code">+vpi -load /usr/local/libexec/covered.vcs.so:covered_register covered_vpi.v</code></strong></span> to 
        the command-line.
      </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="part.command.line.usage.html"><img src="img/prev.gif" alt="Prev"></a> </td><td width="20%" align="center"><a accesskey="u" href="part.command.line.usage.html"><img src="img/up.gif" alt="Up"></a></td><td width="40%" align="right"> <a accesskey="n" href="chapter.using.html"><img src="img/next.gif" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">Part III. Command-line Usage </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="img/home.gif" alt="Home"></a></td><td width="40%" align="right" valign="top"> Chapter 8. Using Covered</td></tr></table></div></body></html>
