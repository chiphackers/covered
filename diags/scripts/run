#!/usr/bin/perl

# Name:     run
# Author:   Trevor Williams  <trevorw(sgi.com)>
# Date:     2/11/2005
# Brief:    Script used for running both regressions and single diagnostics.
# Usage:    run <list_of_groups>

# Defines
$covered = "../../src/covered";

# Global variables
$gflag         = "-Q";
%groups_plus   = ();
%groups_minus  = ();
@groups_to_run = ();
%sim_cmds      = ();
%score_cmds    = ();
%score_output  = ();
%merge_cmds    = ();
%merge_output  = ();
%report_cmds   = ();
%report_output = ();
@passed_diags  = ();
@failed_diags  = ();
$merge_set     = 0;
$report_set    = 0;

if( $env{"COVERED_GFLAG"} ne "" ) {
  $gflag = $env{"COVERED_GFLAG"};
}

# Parse command-line arguments
&parse_args;

# Run diagnostics
&run_diags;

# Output the results
&output_results;

###################################################################3

sub parse_args {

  foreach $arg (@ARGV) {
    if( $arg =~ /^\+(.*)/ ) {
      $groups_plus{$1} = 1;
    } elsif( $arg =~ /^\-(.*)/ ) {
      $groups_minus{$1} = 1;
    } else {
      &usage;
    }
  }

}

sub usage {

  print "Usage:  run <list_of_groups>\n";
  die;

}

sub parse_groups {

  my @line = split( /\s+/, $_[0] );
  my $run  = 0;
  my $group;

  foreach $group (@line) {
    if( $groups_plus{$group} ne "" ) {
      $groups_to_run[@groups_to_run] = $group;
      $run = 1;
    }
  }

  return( $run );

}

sub parse_cmd {

  my $line = $_[0];
  my $run, $cmd;
  my $prereq_list, $cmd_list, $output, @list;

  # Split line based on the colon character
  ($prereq_list,$cmd_list,$output) = split( /:/, $line );

  # Remove unnecessary spaces from cmd_list
  $cmd_list =~ s/^ +//g;
  $cmd_list =~ s/; +/; /g;
  $cmd_list =~ s/ +$//g;

  # Parse prerequisite list
  @list = split( /\s+/, $prereq_list );
  $run  = 1;
  $cmd  = shift( @list );

  if( $cmd eq "SIM" ) {
    $sim_cmds{"@list"}      = "$cmd_list;";
    $sim_output{"@list"}    = $output;
  } elsif( $cmd eq "SCORE" ) {
    $score_cmds{"@list"}    = "$covered $gflag score $cmd_list;";
    $score_output{"@list"}  = $output;
  } elsif( $cmd eq "MERGE" ) {
    $merge_cmds{"@list"}    = "$covered $gflag merge $cmd_list;";
    $merge_output{"@list"}  = $output;
  } elsif( $cmd eq "REPORT" ) {
    $report_cmds{"@list"}   = "$covered $gflag report $cmd_list;";
    $report_output{"@list"} = $output;
  } else {
    $run = 0;
  }

  return( $run );

}

sub parse_diag_header_line {

  my $line = $_[0];
  my $run;

  if( $line =~ /GROUPS(.*)/ ) {
    $run = &parse_groups( $1 );
  } else {
    $run = &parse_cmd( $line );
  }

  return( $run );

}

sub read_diag_info {

  my $diag_name = $_[0];
  my $run = 1;
  my $in_header, $in_output, $name;

  # Clear global variables
  @groups_to_run = ();
  %sim_cmds      = ();
  %score_cmds    = ();
  %score_output  = ();
  %merge_cmds    = ();
  %merge_output  = ();
  %report_cmds   = ();
  %report_output = ();

  open( DIAG, $diag_name ) || die "ERROR:  Unable to read diagnostic $diag_name: $!\n";

  while( ($line = <DIAG>) && ($run == 1) ) {
    chomp( $line );
    if( ($in_header == 0) && ($in_output == 0) ) {
      if( $line =~ /^\s*\/\*\s*HEADER/ ) {
        $in_header = 1;
      } elsif( $line =~ /^\s*\/\*\s*OUTPUT\s+(.*)/ ) {
        $name      = $1;
        $in_output = 1;
        open( OFILE, ">${name}.diag" );
      }
    } elsif( $line =~ /^\s*\*\// ) {
      if( $in_header == 1 ) {
        $in_header = 0;
      } elsif( $in_output == 1 ) {
        $in_output = 0;
        close( OFILE );
      }
    } elsif( $in_header == 1 ) {
      $run = &parse_diag_header_line( $line );
    } elsif( $in_output == 1 ) {
      print OFILE "$line\n";
    }
  }

  close( DIAG );

  return( $run );

}

sub prereqs_contain_a_minus {

  my @prereqs = split( /\s+/, $_[0] );
  my $prereq, $a_minus;

  $a_minus = 0;
  foreach $prereq (@prereqs) {
    if( $groups_minus{$prereq} ne "" ) {
      $a_minus = 1;
    }
  }

  return( $a_minus )

}

sub run_current_diag {

  my $diag_name = $_[0];
  my $output_to_rm = "";
  my $prereqs, $prereq, $ran, %cmds, %output, $i, $error;

  $ran   = 0;
  $error = 0;

  # Initialize prerequisites with the specified groups to run
  $prereqs = join( " ", @groups_to_run );

  # Run diagnostic
  for( $i=0; $i<4; $i++ ) {

    if( $i == 0 ) {             # Compilation/simulation
      %cmds    = %sim_cmds;
      %output  = %sim_output;
    } elsif( $i == 1 ) {        # Score
      %cmds    = %score_cmds;
      %output  = %score_output;
    } elsif( $i == 2 ) {        # Merge
      %cmds    = %merge_cmds;
      %output  = %merge_output;
    } elsif( $i == 3 ) {        # Report
      %cmds    = %report_cmds;
      %output  = %report_output;
    }

    @prereq_list = split( /\s+/, $prereqs );

    foreach $prereq (@prereq_list) {
      foreach $cmd (keys( %cmds )) {
        if( (index( " ${cmd} ", " ${prereq} " ) != -1) && (&prereqs_contain_a_minus( $cmd ) == 0) ) {
          $found_cmd = 0;
          foreach $cmdline (keys( %cmdlines )) {
            if( (index( " $cmdlines{$cmdline} ", " $prereq ") != -1) && ($found == 0) ) {
              $cmdlines_to_run{$cmdline} = 0;
              foreach $outfile (split( /\s+/, $output{$cmd} )) {
                $cmdlines{"$cmdline $cmds{$cmd}"}        = $outfile;
                $cmdlines_to_run{"$cmdline $cmds{$cmd}"} = 1;
                $output_files{$outfile}                  = 1;
              }
              $found_cmd = 1;
            }
          }
          if( $found_cmd == 0 ) {
            foreach $outfile (split( /\s+/, $output{$cmd} )) {
              $cmdlines{"$cmds{$cmd}"}        = $outfile;
              $cmdlines_to_run{"$cmds{$cmd}"} = 1;
              $output_files{$outfile}         = 1;
            }
          }
          $prereqs = join( " ", $prereqs, $output{$cmd} );
        }
      }
    }

  }

  # Run each command-line
  foreach $cmdline (keys( %cmdlines_to_run )) {
    if( $cmdlines_to_run{$cmdline} == 1 ) {
      $error = system( "$cmdline" );
      $ran   = 1;
      if( $error == 0 ) {
        foreach $outfile (keys( %output_files )) {
          if( -e "$outfile.diag" ) {
            $error = system( "diff ${outfile} ${outfile}.diag" );
          }
          if( $error == 0 ) {
            system( "rm -f ${outfile}" );
          } else {
            return( 1, 1, "diff ${outfile} ${outfile}.diag" );
          }
        }
      } else {
        return( 1, 1, $cmdline );
      }
    }
  }

  # Remove diagnostic output files if there were no errors
  foreach $outfile (keys( %output_files )) {
    system( "rm -f ${outfile}.diag" );
  }

  return( ($ran, 0, "") );

}

sub run_diags {

  my $run, $diag_name, $ran, $failed, $failing_cmd;

  opendir( VDIR, "." );

  while( $file = readdir( VDIR ) ) {
    chomp( $file );
    if( $file =~ /(.*)\.v$/ ) {
      $diag_name = $1;
      $run = &read_diag_info( "$diag_name.v" );
      if( $run == 1 ) {
        ($ran, $failed, $failing_cmd) = &run_current_diag( "$diag_name.v" );
        if( $ran == 1 ) {
          if( $failed == 1 ) {
            $failed_diags[@failed_diags] = "$diag_name  ($failing_cmd)";
          } else {
            $passed_diags[@passed_diags] = $diag_name;
          }
        }
      }
    }
  }

  closedir( VDIR );

}

sub output_results {

  my $diag;

  print "\nPassed: " . @passed_diags . ", Failed: " . @failed_diags . "\n";

  if( @failed_diags > 0 ) {
    print "\n";
    print "Failing diagnostics:\n";
    foreach $diag (@failed_diags) {
      print "   $diag\n";
    }
  }

  print "\n";

}
